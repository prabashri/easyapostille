---
// src/pages/tags/index.astro
import { getCollection } from 'astro:content';
import BaseLayout from '../../layouts/BaseLayout.astro';
import { siteDefaults } from '../../config/siteDefaults';
import type { HeadProps } from '../../types/HeadProps';
import { tagMeta } from '../../config/tagMeta';

import { collectFieldCounts } from "../../utils/collectFieldCounts";
import CardCollections from '../../components/ui/CardCollections.astro';
import type { CardProps } from '../../types/CardProps';

// Type definitions
type TagMetaItem = {
  name: string;
  title?: string;
  description?: string;
  image?: string;
  url?: string;
};
type TagWithCount = TagMetaItem & { count: number };

// Map tagMeta for quick lookup
const tagMetaMap = new Map<string, TagMetaItem>(
  Object.entries(tagMeta).map(([name, meta]) => [
    name.toLowerCase(),
    { name, ...meta }
  ])
);

const entry = "tags";

// Get tag counts (first 3 per post max)
const tagCountsArray = await collectFieldCounts(entry, 3);

// Arrays for known & unknown tags
const knownTags: TagWithCount[] = [];
const unknownTags: TagWithCount[] = [];

// Helper to format unknown tag titles
function formatTitle(tag: string): string {
  return tag
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

// Separate tags into known vs unknown
for (const { name, count } of tagCountsArray) {
  const tagEntry = tagMetaMap.get(name);
  if (tagEntry) {
    knownTags.push({ ...tagEntry, count });
  } else {
    unknownTags.push({
      name,
      title: formatTitle(name),
      description: `Posts related to ${formatTitle(name)}.`,
      image: `/${entry}/default-image.png`,
      url: `/${entry}/${name}/`,
      count
    });
  }
}

// Merge tags: Known first, then Unknown
const mergedTags: TagWithCount[] = [...knownTags, ...unknownTags];

// SEO setup
const headProps: HeadProps = {
  title: `All | ${siteDefaults.siteName}`,
  description: `Explore all tags used across tools, guides, and blog posts on ${siteDefaults.siteName}.`,
  image: siteDefaults.image,
  canonicalUrl: `${siteDefaults.siteUrl}/${entry}/`,
  index: true,
  keywords: mergedTags.map(t => t.name),
  type: 'collection',
  url: `${siteDefaults.siteUrl}/${entry}/`,
  authors: [],
  authorName: siteDefaults.authorName,
  authorUrl: siteDefaults.authorUrl,
};

// Map tags to CardProps
function mapToCardProps(tag: TagWithCount, index: number): CardProps {
  return {
    link: tag.url ?? `/${entry}/${tag.name}/`,
    linkAriaLabel: `View all posts tagged ${tag.title ?? tag.name}`,
    image: tag.image ?? '',
    imageAlt: tag.title ?? tag.name,
    title: tag.title ?? tag.name,
    description: tag.description ?? '',
    afterDescription: `${tag.count} posts`,
    orientation: 'vertical',
    imageSize: 320,
    roleType: 'list',
    loading: index < 3 ? 'eager' : 'lazy' // First 3 tags eager
  };
}

// Final merged cards
const mergedTagCards: CardProps[] = mergedTags.map((tag, index) => mapToCardProps(tag, index));

---

<BaseLayout headProps={headProps}>
  <div id="collections-header" class="mx-w-site mi-auto ta-center">
    <h1>{siteDefaults.fieldCollections[entry].title}</h1>
    <p>{siteDefaults.fieldCollections[entry].description}</p>
  </div>

  {mergedTagCards.length > 0 && (
    <section class="mx-w-site mi-auto mb-2">
      <CardCollections cards={mergedTagCards} wrapper="ul" roleType='list' entry={entry}/>
    </section>
  )}
</BaseLayout>
