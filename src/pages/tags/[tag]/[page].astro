---
import BaseLayout from '../../../layouts/BaseLayout.astro';
import PaginationSeo from '../../../components/PaginationSeo.astro';
import PaginationRedirect from '../../../components/PaginationRedirect.astro';
import Pagination from '../../../components/Pagination.astro';
import CardCollections from '../../../components/ui/CardCollections.astro';

import { getCollection } from 'astro:content';
import { siteDefaults } from '../../../config/siteDefaults';
import { paginate } from '../../../utils/paginate';
import type { HeadProps } from '../../../types/HeadProps';
import { tagMeta } from '../../../config/tagMeta';
import modifiedDatesJson from '../../../data/modified-dates.json';
import { getCollectionUrl } from '../../../utils/getCollectionUrl';
import type { CardProps } from '../../../types/CardProps';

const entryType = "tags";
const currentTag = Astro.params.tag?.toLowerCase() ?? 'unknown';
const currentPage = Number(Astro.params.page ?? '1');
const POSTS_PER_PAGE = siteDefaults.postsPerCollectionsPage ?? 10;

const modifiedDates = modifiedDatesJson as Record<string, string>;

function getModifiedDateKey(entry: any) {
  const key = `${entry.collection}/${entry.slug ?? entry.id}`;
  return modifiedDates[key] ?? entry.data.lastModified ?? entry.data.publishedDate ?? entry.data.date;
}

const tagMetaMap = new Map<string, { name: string; title?: string; description?: string; image?: string; url?: string }>(
  Object.entries(tagMeta).map(([name, meta]) => [name.toLowerCase(), { name, ...meta }])
);

function hasTag(post: any, tag: string): boolean {
  return Array.isArray(post.data?.tags) &&
    post.data.tags.some((t: string) => t.toLowerCase() === tag.toLowerCase());
}

// Collect tagged posts
const taggedCollections = Object.entries(siteDefaults.collections)
  .filter(([_, config]) => config?.tags === true)
  .map(([key]) => key as keyof typeof siteDefaults.collections);

let matchedEntries: any[] = [];
for (const coll of taggedCollections) {
  const posts = await getCollection(coll);
  matchedEntries.push(...posts.filter(entry => hasTag(entry, currentTag)));
}

// Sort entries by modified date
matchedEntries.sort((a, b) => new Date(getModifiedDateKey(b)).getTime() - new Date(getModifiedDateKey(a)).getTime());

// Pagination
const { pageItems: paginatedEntries, totalPages } = paginate(matchedEntries, currentPage, POSTS_PER_PAGE);

// Meta
const meta = tagMetaMap.get(currentTag) ?? {
  name: currentTag,
  title: currentTag.charAt(0).toUpperCase() + currentTag.slice(1),
  description: `Explore posts tagged "${currentTag}" on ${siteDefaults.siteName}.`,
  image: `/${siteDefaults.fieldCollections[entryType].defaultImage}`,
  url: `/${entryType}/${currentTag}/`
};

const baseUrl = `/${entryType}/${currentTag}`;

// Other tags from posts
let otherTagsSet = new Set<string>();
for (const post of matchedEntries) {
  if (Array.isArray(post.data?.tags)) {
    post.data.tags.forEach((t: string) => {
      if (t.toLowerCase() !== currentTag) otherTagsSet.add(t.toLowerCase());
    });
  }
}
const otherTagsEntries = Array.from(otherTagsSet).sort();

// SEO props
const pageSeo: HeadProps = {
  title: `${meta.title} | ${siteDefaults.siteName}`,
  description: meta.description,
  image: meta.image || siteDefaults.image,
  breadcrumb: [
    { name: 'Home', url: '/' },
    { name: siteDefaults.fieldCollections[entryType].title, url: `/${entryType}/` },
    { name: meta.title ?? currentTag, url: `${baseUrl}/` },
  ],
  listItems: paginatedEntries.map(p => ({
    name: "title" in p.data ? p.data.title : 'Untitled',
    url: getCollectionUrl(p.collection, "slug" in p.data && typeof p.data.slug === "string" ? p.data.slug : String(p.id))
  })),
  type: 'collection',
  index: paginatedEntries.length > 0,
  authors: [] // âœ… No authors needed for collection pages
};

// Map entries to CardProps
function mapEntryToCard(entry: any, index: number): CardProps {
  const postDate = getModifiedDateKey(entry);

  const otherTags = entry.data?.tags?.filter(
    (t: string) => t.toLowerCase() !== currentTag
  ) || [];

  const otherEntries = otherTags
    .map((tagName: string) => {
      const formatted = tagName.charAt(0).toUpperCase() + tagName.slice(1);
      return {
        name: tagName.toLowerCase(),
        label: formatted,
        url: `/${entryType}/${tagName.toLowerCase()}/`
      };
    })
    .sort((a: { label: string }, b: { label: string }) => a.label.localeCompare(b.label));

  return {
    link: getCollectionUrl(
      entry.collection,
      typeof entry.data.slug === "string" ? entry.data.slug : String(entry.id)
    ),
    linkAriaLabel: `View post: ${"title" in entry.data ? entry.data.title : "Untitled"}`,
    image: "heroImage" in entry.data ? entry.data.heroImage : siteDefaults.image,
    imageAlt:
      "heroImageAlt" in entry.data
        ? entry.data.heroImageAlt
        : "title" in entry.data
        ? entry.data.title
        : 'Post image',
    otherEntries,
    title: "title" in entry.data ? entry.data.title : 'Untitled',
    description: "description" in entry.data ? entry.data.description : '',
    date: postDate
      ? new Date(postDate).toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'short',
          day: '2-digit'
        })
      : '',

    orientation: 'vertical',
    imageSize: 320,
    roleType: 'list',
    loading: index < 3 ? 'eager' : 'lazy'
  };
}

const postCards: CardProps[] = paginatedEntries.map((entry, idx) => mapEntryToCard(entry, idx));
---

<BaseLayout headProps={pageSeo}>
  <PaginationRedirect basePath={baseUrl} currentPage={currentPage} />
  <PaginationSeo basePath={baseUrl} currentPage={currentPage} totalPages={totalPages} />

  <header class="mx-w-site mi-auto ta-center">
    <h1>{meta.title}</h1>
    <p>{meta.description}</p>
  </header>

  {paginatedEntries.length === 0 ? (
    <p class="ta-center mt-2">No posts found for this tag.</p>
  ) : (
    <section class="mx-w-site mi-auto mt-2">
      <CardCollections cards={postCards} wrapper="ul" roleType="list" entry={entryType}/>
    </section>
  )}


  <Pagination currentPage={currentPage} totalPages={totalPages} basePath={baseUrl} />
</BaseLayout>
