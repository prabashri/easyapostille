---
import imageMetadataJson from '../data/image-format-details.json';
import { registerPreloadImage } from '../utils/preloadRegistry';
import { registerSchemaImage } from '../utils/registerSchemaImage';
import { siteDefaults } from '../config/siteDefaults';
import { siteImages } from '../config/siteImages';
import { getAbsoluteImageUrl } from '../utils/getAbsoluteImageUrl';

interface Props {
  src: string;
  alt: string;
  width?: string | number;
  height?: number;
  title?: string;
  id?: string;
  className?: string;
  imageClassName?: string;
  caption?: string;
  loading?: 'lazy' | 'eager' | 'delay';
  sizes?: string;
  breakpoints?: { mobile?: number; desktop?: number };
  objectFit?: 'cover' | 'contain' | 'fill' | 'none' | 'scale-down';
  addSchema?: boolean;
}

const {
  src,
  alt,
  title,
  id ="", 
  className = '',
  imageClassName = 'inline-image',
  objectFit = 'cover',
  caption,
  loading = 'lazy',
  sizes,
  breakpoints,
  height,
  width,
  addSchema = true
} = Astro.props as Props;

const mobileMax = siteImages.breakpoints.mobileMax ?? 768;
const desktopMin = siteImages.breakpoints.desktopMin ?? 769;

const metadata = imageMetadataJson as Record<string, any>;
const data = metadata[src];
const origin = siteDefaults.siteUrl.endsWith('/')
  ? siteDefaults.siteUrl.slice(0, -1)
  : siteDefaults.siteUrl;
const folderPath = siteImages.outputImageBase?.replace(/^\.\/public\//, '') || 'images';

let hasData = !!data;
let targetWidth = breakpoints?.desktop ?? (typeof width === 'number' ? width : 320);

let basePath = '';
let availableWidths: number[] = [];
let defaultAspect = '';
let formats: string[] = [];
let sizesAttr = sizes;
let widthMax = targetWidth;
let imageBaseName = '';
let fallbackSrc = '';
let aspectClass = '';
let objectFitClass = '';
let imageMaxUrl = '';
let srcSetList = '';

if (hasData) {

  basePath = `/${folderPath}${data.path}`;
  availableWidths = data.variants.map(Number).sort((a: number, b: number) => a - b);
  defaultAspect = data.aspect;

  // ✅ Format priority
  const formatPriority: Record<string, number> = { webp: 1, png: 2, jpeg: 3, jpg: 3, avif: 4 };
  formats = [...data.format].sort(
    (a, b) => (formatPriority[a.toLowerCase()] ?? 99) - (formatPriority[b.toLowerCase()] ?? 99)
  );

  // ✅ Sizes
  const mobileBP = breakpoints?.mobile ?? 320;
  const desktopBP = breakpoints?.desktop ?? mobileBP;
  widthMax = Math.max(...availableWidths);

  if (!sizesAttr) {
    if (mobileBP === desktopBP) {
      sizesAttr = `${mobileBP}px`;
    } else {
      sizesAttr = `(max-width: ${mobileMax}px) ${mobileBP}px, (max-width: 1280px) ${desktopBP}px, ${widthMax}px`;
    }
  }

  // ✅ Widths
  const mWidth = availableWidths.find(w => w >= mobileBP) ?? availableWidths[0];
  const dWidth = availableWidths.find(w => w >= desktopBP) ?? mWidth;

  // ✅ srcset
  const buildSrc = (w: number, fmt: string) => `${basePath}${imageBaseName}-w${w}-a${defaultAspect}.${fmt}`;
  imageBaseName = src.replace(/^.*[\/]/, '').replace(/\.[^.]+$/, '');
  fallbackSrc = buildSrc(mWidth, formats[0]);
  imageMaxUrl = `${origin}${buildSrc(widthMax, formats[0])}`;

  srcSetList = (mobileBP === desktopBP)
    ? `${buildSrc(mWidth, formats[0])} ${mWidth}w, ${buildSrc(widthMax, formats[0])} ${widthMax}w`
    : `${buildSrc(mWidth, formats[0])} ${mWidth}w, ${buildSrc(dWidth, formats[0])} ${dWidth}w, ${buildSrc(widthMax, formats[0])} ${widthMax}w`;

  // ✅ Classes
  aspectClass = `a-${defaultAspect}`;

  objectFitClass = `object-${objectFit}`;

  // ✅ Preload from srcset
  if (loading === 'eager' || loading === 'delay') {
    const priority = loading === 'eager' ? 'high' : 'low';
    const srcsetParts = srcSetList.split(',');
    srcsetParts.forEach(entry => {
      const match = entry.trim().match(/(.*)\s+(\d+)w$/);
      if (match) {
        const [ , url, width ] = match;
        const media = (parseInt(width) <= mobileBP)
          ? `(max-width: ${mobileMax}px)`
          : (parseInt(width) < widthMax ? `(min-width: ${desktopMin}px)` : undefined);
        registerPreloadImage({ src: url.trim(), media, fetchPriority: priority });
      }
    });
  }

  // ✅ Schema
    if (addSchema) {
      registerSchemaImage(imageMaxUrl);
    }

}
---

{addSchema && hasData && (
  <script is:inline type="application/ld+json" set:html={JSON.stringify({
    '@context': 'https://schema.org',
    '@type': 'ImageObject',
    '@id': imageMaxUrl,
    contentUrl: imageMaxUrl,
    url: imageMaxUrl,
    caption: caption || title || alt,
    description: alt,
    representativeOfPage: true,
    width: widthMax,
    height: Math.round(widthMax * (Number(defaultAspect.split('x')[1]) / Number(defaultAspect.split('x')[0])))
  })} />
)}

{!hasData ? (
  <div class={`flex ai-center jc-center bg-primary-lighter ${aspectClass} ${loading === 'delay' ? 'opacity-02 transition-opacity duration-300' : ''} h-fit ${className}`}>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 225" class={`w-full h-auto ${imageClassName} ${objectFitClass}`}>
      <rect width="400" height="225" fill="#00000000"></rect>
    </svg>
    <span class="absolute bold text-base">{siteDefaults.siteName}</span>
  </div>
) : (
  <>
    {caption ? (
      <figure id={id} class={`block image-wrapper mx-w-95-0 ${aspectClass} h-fit ${className}`}>
        <picture>
          {formats.map(fmt => (
            <source
              type={`image/${fmt === 'jpg' ? 'jpeg' : fmt}`}
              srcset={srcSetList.replace(new RegExp(`\\.${formats[0]}`, 'g'), `.${fmt}`)}
              sizes={sizesAttr}
            />
          ))}
          <img
            src={fallbackSrc}
            srcset={srcSetList}
            sizes={sizesAttr}
            width={width ?? availableWidths[0]}
            height={height}
            alt={alt}
            title={title}
            loading={loading === 'delay' ? 'lazy' : loading}
            decoding="async"
            fetchpriority={loading === 'eager' ? 'high' : undefined}
            class={`block w-full h-auto br ${imageClassName} ${objectFitClass} ${loading === 'delay' ? 'opacity-0 transition-opacity duration-300' : ''}`}
          />
        </picture>
        <figcaption class="text-s">{caption}</figcaption>
      </figure>
    ) : (
      <picture id={id} class={`block image-wrapper mx-w-95-0 ${aspectClass} h-fit ${className}`}>
        {formats.map(fmt => (
          <source
            type={`image/${fmt === 'jpg' ? 'jpeg' : fmt}`}
            srcset={srcSetList.replace(new RegExp(`\\.${formats[0]}`, 'g'), `.${fmt}`)}
            sizes={sizesAttr}
          />
        ))}
        <img
          src={fallbackSrc}
          srcset={srcSetList}
          sizes={sizesAttr}
          width={width ?? availableWidths[0]}
          height={height}
          alt={alt}
          title={title}
          loading={loading === 'delay' ? 'lazy' : loading}
          decoding="async"
          fetchpriority={loading === 'eager' ? 'high' : undefined}
          class={`block w-full h-auto br ${imageClassName} ${objectFitClass} ${loading === 'delay' ? 'opacity-0 transition-opacity duration-300' : ''}`}
        />
      </picture>
    )}
  </>
)}
