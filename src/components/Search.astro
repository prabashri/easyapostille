---
// src/components/Search.astro

---

<style>
  .search-box { margin-bottom: 1rem; }
  .search-input {
    width: 100%;
    padding: 0.5rem;
    font-size: 1rem;
  }
  .search-results li {
    margin: 0.5rem 0;
    border-bottom: 1px solid #ddd;
    padding-bottom: 0.5rem;
  }
  mark {
  background-color: #ffeb3b;
  color: inherit;
  padding: 0 2px;
}
.search-results {
  list-style: none;
  padding: 0;
}
.search-results h3 {
  margin-top: 1rem;
  font-size: 1.1rem;
}

</style>

<div id="search" class="search-box">
  <input
    type="search"
    id="search-input"
    class="search-input"
    placeholder="Search articles, pages…"
    value=""
    autocomplete="off"
  />
  <ul id="search-results"></ul>
</div>
<script type="module">
  // Wait for Fuse to be available globally
  async function waitForFuse() {
    if (window.Fuse) return window.Fuse;
    await import('/vendor/fuse.min.js'); // loads script but doesn’t return usable object
    return new Promise((resolve) => {
      const check = () => {
        if (window.Fuse) resolve(window.Fuse);
        else requestAnimationFrame(check);
      };
      check();
    });
  }

  const input = document.getElementById('search-input');
  const resultsContainer = document.getElementById('search-results');
  const params = new URLSearchParams(window.location.search);
  const qParam = params.get('q') || '';

  let fuse;
  let data = [];
  let debounceTimer;

  async function loadData() {
    const Fuse = await waitForFuse(); // ensure global Fuse is available
    const res = await fetch('/search-index.json');
    data = await res.json();
    fuse = new Fuse(data, {
      keys: ['title', 'description', 'content', 'tags'],
      threshold: 0.3,
      ignoreLocation: true,
      includeMatches: true,
    });

    if (qParam) {
      input.value = qParam;
      search(qParam);
    }
  }

    function highlight(text, match = {}) {
    const indices = match?.indices;
    if (!Array.isArray(indices)) return text;

    let highlighted = text;
    indices.slice().reverse().forEach(([start, end]) => {
        highlighted = `${highlighted.slice(0, start)}<mark>${highlighted.slice(start, end + 1)}</mark>${highlighted.slice(end + 1)}`;
    });
    return highlighted;
    }

    const groupStates = {}; // store how many items shown per group

    function renderResults(results) {
    resultsContainer.innerHTML = '';
    if (!results.length) return;

    const groups = {};

    for (const result of results) {
        const { item, matches } = result;
        const group = item.collection || 'other';
        groups[group] = groups[group] || [];
        groups[group].push({ item, matches });
    }

    Object.entries(groups).forEach(([group, items]) => {
        const header = document.createElement('h3');
        header.textContent = group.charAt(0).toUpperCase() + group.slice(1);
        resultsContainer.appendChild(header);

        const listContainer = document.createElement('ul');
        listContainer.classList.add('search-results');
        resultsContainer.appendChild(listContainer);

        const matchMapArr = items.map(({ item, matches }) => ({
        item,
        matchMap: Object.fromEntries(matches.map(m => [m.key, m])),
        }));

        // track how many items are shown per group
        const shownCount = groupStates[group] ?? 0;
        const initialCount = shownCount || 2;
        groupStates[group] = initialCount;

        const renderItems = () => {
        const toRender = matchMapArr.slice(0, groupStates[group]);
        listContainer.innerHTML = '';
        toRender.forEach(({ item, matchMap }) => {
            const li = document.createElement('li');
            li.innerHTML = `
            <a href="${item.url}" style="font-weight: bold;">
                ${highlight(item.title, matchMap.title?.indices)}
            </a>
            <p>${highlight(item.description ?? '', matchMap.description?.indices)}</p>
            `;
            listContainer.appendChild(li);
        });
        };

        renderItems();

        if (matchMapArr.length > groupStates[group]) {
        const loadMoreBtn = document.createElement('button');
        loadMoreBtn.textContent = 'Load More';
        loadMoreBtn.style.marginTop = '0.5rem';
        loadMoreBtn.style.padding = '0.5rem';
        loadMoreBtn.style.fontSize = '1rem';

        loadMoreBtn.addEventListener('click', () => {
            groupStates[group] += 10;
            renderItems();

            if (groupStates[group] >= matchMapArr.length) {
            loadMoreBtn.remove(); // all items shown
            }
        });

        resultsContainer.appendChild(loadMoreBtn);
        }
    });
    }




  function search(query) {
    if (!fuse || query.length < 2) {
      resultsContainer.innerHTML = '';
      return;
    }
    const results = fuse.search(query);
    renderResults(results);
  }

  input?.addEventListener('input', (e) => {
    const query = e.target.value.trim();
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => {
      search(query);
      const newURL = new URL(window.location.href);
      if (query) {
        newURL.searchParams.set('q', query);
      } else {
        newURL.searchParams.delete('q');
      }
      window.history.replaceState({}, '', newURL.toString());
    }, 300);
  });

  loadData();
</script>

